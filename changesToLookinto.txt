/*******************RENDERING OPTIMIZATION************************************/

// Create sphere VBO/VAO once
void setupSphereGeometry() {
    // Generate sphere vertices once
    // Store in VBO
}

// Render many spheres efficiently
void renderNodes() {
    // Bind shader program
    glBindVertexArray(sphereVAO);
    
    // Use instancing to draw all nodes at once
    glBindBuffer(GL_ARRAY_BUFFER, nodePositionsVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float3) * numberOfNodes, nodePositions, GL_DYNAMIC_DRAW);
    
    glDrawArraysInstanced(GL_TRIANGLES, 0, sphereVertexCount, numberOfNodes);
}

/***********************************CUDA + OpenGL WORKING TOGETHER*************************/

// Register OpenGL buffer with CUDA
cudaGraphicsResource *cudaNodePosResource;
cudaGraphicsGLRegisterBuffer(&cudaNodePosResource, nodePositionsVBO, cudaGraphicsMapFlagsWriteDiscard);

// In simulation loop:
float3 *devPtr;
size_t size;
cudaGraphicsMapResources(1, &cudaNodePosResource);
cudaGraphicsResourceGetMappedPointer((void**)&devPtr, &size, cudaNodePosResource);

// Run kernel that directly updates the mapped OpenGL buffer
updateNodePositions<<<blocks, threads>>>(devPtr, ...);

cudaGraphicsUnmapResources(1, &cudaNodePosResource);
// Now render without needing to transfer data back to CPU


/*******************************************************************************************************/




COPILOT SUGGESTIONS----- 
    /**********spatial paritioning??????***********/

    // Setup uniform grid
    void setupGrid() {
        // Divide space into cells
        // Create grid data structure
    }

    // Use grid to find nearby nodes efficiently
    __global__ void getForces() {
        // Get only neighbors in nearby grid cells instead of checking all nodes
        // This changes O(nÂ²) operations to O(n)
    }